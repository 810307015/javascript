### JavaScript相关知识点

1. `instanceof`原理。通过递归去比较目标对象的隐式原型与原始对象的原型，只要隐式原型链上找到了，就返回true。

```js
function instance_of(target, origin) {
    if(typeof target !== 'object' || typeof origin !== 'object') {
        return false;
    }
    var O = origin.prototype; // 原始对象的原型
    var target = target._proto_; // 目标对象的隐式原型
    while(true) {
        if(target === null) {
            return false;
        }
        if(target === O) {
            return true;
        }
        target = target._proto_;
    }
}
```

2. `Promise`。`Promise`的当前状态只能是`pending`，`fulfilled`，`rejected`三种之一。状态改变只能是`pending`到`fulfilled`，或者`pending`到`rejected`。`then`方法接收两个可选参数，`promise.then(onFulfilled, onRejected)`。

```js
var Promise = (function() {
    function Promise(resolver) {
        if (typeof resolver !== 'function') { //resolver必须是函数
            throw new TypeError('Promise resolver ' + resolver + ' is not a function')
        }
        if (!(this instanceof Promise)) return new Promise(resolver)

        var self = this //保存this
        self.callbacks = [] //保存onResolve和onReject函数集合
        self.status = 'pending' //当前状态

        function resolve(value) {
            setTimeout(function() { //异步调用
                if (self.status !== 'pending') {
                    return
                }
                self.status = 'resolved' //修改状态
                self.data = value

                for (var i = 0; i < self.callbacks.length; i++) {
                    self.callbacks[i].onResolved(value)
                }
            })
        }

        function reject(reason) {
            setTimeout(function(){ //异步调用
                if (self.status !== 'pending') {
                    return
                }
                self.status = 'rejected' //修改状态
                self.data = reason

                for (var i = 0; i < self.callbacks.length; i++) {
                    self.callbacks[i].onRejected(reason)
                }
            })
        }

        try{
            resolver(resolve, reject) //执行resolver函数
        } catch(e) {
            reject(e)
        }
    }

    function resolvePromise(promise, x, resolve, reject) {
        var then
        var thenCalledOrThrow = false

        if (promise === x) {
            return reject(new TypeError('Chaining cycle detected for promise!'))
        }

        if ((x !== null) && ((typeof x === 'object') || (typeof x === 'function'))) {
            try {
                then = x.then
                if (typeof then === 'function') {
                    then.call(x, function rs(y) {
                        if (thenCalledOrThrow) return
                        thenCalledOrThrow = true
                        return resolvePromise(promise, y, resolve, reject)
                    }, function rj(r) {
                        if (thenCalledOrThrow) return
                        thenCalledOrThrow = true
                        return reject(r)
                    })
                } else {
                    return resolve(x)
                }
            } catch(e) {
                if (thenCalledOrThrow) return
                thenCalledOrThrow = true
                return reject(e)
            }
        } else {
            return resolve(x)
        }
    }

    Promise.prototype.then = function(onResolved, onRejected) {
        //健壮性处理，处理点击穿透
        onResolved = typeof onResolved === 'function' ? onResolved : function(v){return v}
        onRejected = typeof onRejected === 'function' ? onRejected : function(r){throw r}
        var self = this
        var promise2

        //promise状态为resolved
        if (self.status === 'resolved') {
            return promise2 = new Promise(function(resolve, reject) {
                setTimeout(function() {
                    try {
                        //调用then方法的onResolved回调
                        var x = onResolved(self.data)
                        //根据x的值修改promise2的状态
                        resolvePromise(promise2, x, resolve, reject)
                    } catch(e) {
                        //promise2状态变为rejected
                        return reject(e)
                    }
                })
            })
        }

        //promise状态为rejected
        if (self.status === 'rejected') {
            return promise2 = new Promise(function(resolve, reject) {
                setTimeout(function() {
                    try {
                        //调用then方法的onReject回调
                        var x = onRejected(self.data)
                        //根据x的值修改promise2的状态
                        resolvePromise(promise2, x, resolve, reject)
                    } catch(e) {
                        //promise2状态变为rejected
                        return reject(e)
                    }
                })
            })
        }

        //promise状态为pending
        //需要等待promise的状态改变
        if (self.status === 'pending') {
            return promise2 = new Promise(function(resolve, reject) {
                self.callbacks.push({
                    onResolved: function(value) {
                        try {
                            //调用then方法的onResolved回调
                            var x = onResolved(value)
                            //根据x的值修改promise2的状态
                            resolvePromise(promise2, x, resolve, reject)
                        } catch(e) {
                            //promise2状态变为rejected
                            return reject(e)
                        }
                    },
                    onRejected: function(reason) {
                        try {
                            //调用then方法的onResolved回调
                            var x = onRejected(reason)
                            //根据x的值修改promise2的状态
                            resolvePromise(promise2, x, resolve, reject)
                        } catch(e) {
                            //promise2状态变为rejected
                            return reject(e)
                        }
                    }
                })
            })
        }
    }

    //获取当前Promise传递的值
    Promise.prototype.valueOf = function() {
        return this.data
    }

    //由then方法实现catch方法
    Promise.prototype.catch = function(onRejected) {
        return this.then(null, onRejected)
    }

    //finally方法
    Promise.prototype.finally = function(fn) {
        return this.then(function(v){
            setTimeout(fn)
            return v
        }, function(r){
            setTimeout(fn)
            throw r
        })
    }

    Promise.prototype.spread = function(fn, onRejected) {
        return this.then(function(values) {
            return fn.apply(null, values)
        }, onRejected)
    }

    Promise.prototype.inject = function(fn, onRejected) {
        return this.then(function(v) {
            return fn.apply(null, fn.toString().match(/\((.*?)\)/)[1].split(',').map(function(key){
                return v[key];
            }))
        }, onRejected)
    }

    Promise.prototype.delay = function(duration) {
        return this.then(function(value) {
            return new Promise(function(resolve, reject) {
                setTimeout(function() {
                    resolve(value)
                }, duration)
            })
        }, function(reason) {
            return new Promise(function(resolve, reject) {
                setTimeout(function() {
                    reject(reason)
                }, duration)
            })
        })
    }

    Promise.all = function(promises) {
        return new Promise(function(resolve, reject) {
            var resolvedCounter = 0
            var promiseNum = promises.length
            var resolvedValues = new Array(promiseNum)
            for (var i = 0; i < promiseNum; i++) {
                (function(i) {
                    Promise.resolve(promises[i]).then(function(value) {
                        resolvedCounter++
                        resolvedValues[i] = value
                        if (resolvedCounter == promiseNum) {
                            return resolve(resolvedValues)
                        }
                    }, function(reason) {
                        return reject(reason)
                    })
                })(i)
            }
        })
    }

    Promise.race = function(promises) {
        return new Promise(function(resolve, reject) {
            for (var i = 0; i < promises.length; i++) {
                Promise.resolve(promises[i]).then(function(value) {
                    return resolve(value)
                }, function(reason) {
                    return reject(reason)
                })
            }
        })
    }

    Promise.resolve = function(value) {
        var promise = new Promise(function(resolve, reject) {
            resolvePromise(promise, value, resolve, reject)
        })
        return promise
    }

    Promise.reject = function(reason) {
        return new Promise(function(resolve, reject) {
            reject(reason)
        })
    }

    Promise.fcall = function(fn){
        // 虽然fn可以接收到上一层then里传来的参数，但是其实是undefined，所以跟没有是一样的，因为resolve没参数啊
        return Promise.resolve().then(fn)
    }

    Promise.done = Promise.stop = function(){
        return new Promise(function(){})
    }

    Promise.deferred = Promise.defer = function() {
        var dfd = {}
        dfd.promise = new Promise(function(resolve, reject) {
            dfd.resolve = resolve
            dfd.reject = reject
        })
        return dfd
    }

    try { // CommonJS compliance
        module.exports = Promise
    } catch(e) {}

    return Promise
})()
```

3. `typeof`的原理。在 `javascript` 的最初版本中，使用的`32`位系统，为了性能考虑使用低位存储了变量的类型信息。
    - 000：对象
    - 1：整数
    - 010：浮点数
    - 100：字符串
    - 110：布尔
    - undefined：用 - （−2^30）表示。
    - null：对应机器码的`NULL`指针，一般是全零。
    - 可以返回的数据类型。undefined，string，boolean，number，symbol，object，function
4. js的数据类型：
    - 值类型(基本类型)：字符串（`String`）、数字(`Number`)、布尔(`Boolean`)、对空（`Null`）、未定义（`Undefined`）、`Symbol`。
    - 引用数据类型：对象(`Object`)、数组(`Array`)、函数(`Function`)。数组、函数通常也被归纳为对象类型。所以引用类型也可以说是只有Object一种。
5. 闭包。
    - 定义：闭包就是一个函数，但是这个函数可以访问到另一个函数的作用域。通常是由父函数包裹着子函数形成的，子函数可以访问到父函数中的变量，且该变量在整个生命周期中不会被销毁。
    - 原理：利用了作用域链的特性。在当前环境下访问某个变量时，如果不存在就会一直向外寻找，最终找到最外层的全局作用域，整体就形成了一个作用域链。
    - 优缺点，不会被回收既是优点也是缺点：
        1. 隐藏变量，防止全局污染。（优点）
        2. 读取另一个函数作用域的变量。（优点）
        3. 变量始终保持在内存中，针对全局共享的数据防止被回收。（优点）
        4. 变量不会被垃圾回收回收，内存占用变大。（缺点）
    - 应用场景：
        1. 封装对象的私有属性和私有方法。
        2. 循环中使用闭包解决var定义的下标无法正确遍历的问题。（现在直接用let就轻松解决）
        3. 缓存计算结果的cache，比如在计算量比较大的方法中去缓存输入对应的输出结果，牺牲内存去提高运行性能。（利用其持久性）
        4. 模拟块级作用域。
        5. Vue的响应式对象以及React的hooks都是通过闭包实现的。
        6. 函数柯里化。
        7. 实现单例模式。
6. 原型链。
    - `prototype`。`prototype`属性，它是函数所独有的，它是从一个函数指向一个对象。它的含义是函数的原型对象，也就是这个函数（其实所有函数都可以作为构造函数）所创建的实例的原型对象; 这个属性是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法（我们把这个对象叫做原型对象）。
    - `__proto__`。原型链查询中实际用到的，它总是指向`prototype`，换句话说就是指向构造函数的原型对象，它是对象独有的。
    - `constructor`。每个函数都有一个原型对象，该原型对象有一个`constructor`属性，指向创建对象的函数本身。
    - 总的来说，所有的对象都是通过构造方法去初始化的，当初始化完成后，创建的对象就拥有了一个`_proto_`的隐式原型以及构造其对象本身的构造器`contructor`，这个隐式原型会指向构造方法的真实原型`prototype`。然后寻找对象上的属性和方法时，会沿着原型链层层向上寻找，直到寻找到`prototype`为`null`为止。
    - 使用场景：
        1. 构建自定义对象。
        2. 为js原始的数据类型添加自定义的方法，这样做会污染基本对象的原型链，不建议这么做。
        3. 提供一种模拟面向对象的继承和多态的实现。
7. 函数柯里化与反柯里化。
    - 定义：在计算机科学中，柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。反柯里化是基于柯里化的一种反过来的思想，使本来作为特定对象所拥有的函数可以被任意对象使用。
    - 实现：
    
    ```js
    // 函数柯里化的实现，将add的计算参数缓存起来，直到没有参数传入时开始计算并返回结果
    let add = (function () {
        let args = [];
        return function () {
            if (arguments.length === 0) {
                let result = 0;
                for(let i = 0; i < args.length; i++) {
                    result += args[i];
                }
                return result;
            } else {
                Array.prototype.push.apply(args, arguments);
                // arguments.callee在这里指的是被add返回的匿名方法
                // console.log(arguments.callee.toString())
                return arguments.callee;
            }
        }
    })();
    console.log(add(1)(2, 3)(4, 5, 6)(7, 8, 9, 10)()); // 55

    // 封装一个通用的currying方法，来实现方法的柯里化。
    let currying = function (fn) {
        let args = [];

        return function () {
            if (arguments.length === 0) {
                // console.log(this === global); // true
                return fn.apply(this, args);
            } else {
                [].push.apply(args, arguments);
                // console.log(arguments.callee) 
                // Function,callee为一个指向该拥有该arguments的函数的指针
                return arguments.callee;
            }
        }
    };

    let multiCurry = currying(function () {
        let result = 1;
        for (var i = 0; i < arguments.length; i++) {
            result *= arguments[i];
        }
        return result;
    });

    console.log(multiCurry(1)(2, 3)(4, 5, 6)(7, 8, 9, 10)()); // 3628800
    // 反柯里化的实现，把数组的push方法给对象使用
    Function.prototype.uncurrying = function () {
        let self = this;

        return function () {
            let obj = Array.prototype.shift.call(arguments);
            return self.apply(obj, arguments);
        }
    }
    let push = Array.prototype.push.uncurrying(); //这个时候self就是指向push方法的一个指针
    let obj = {
        a: 1,
        b: 2,
        c: 3,
        length: 3, // 最好是给对象添加一个length属性，因为在使用push方法后会自动给改对象增加一个length属性，并从零开始计算。如果该对象本身有一个length属性，那么会把length属性的值叠加。
    };
    push(obj, 4);
    push(obj, 5);
    push(obj, 6);
    console.log(obj); // { '3': 4, '4': 5, '5': 6, a: 1, b: 2, c: 3, length: 6 }
    ```
8. 箭头函数。ES6推出来的一种新的匿名函数，没有自己的`this`，`arguments`，`super`或`new.target`。
    - 特点：
        1. 不绑定`this`指的是箭头函数内部的`this`指向定义它的时候的上下文作用域。
        2. 由于箭头函数没有自己的this指针，通过 call() 或 apply() 方法调用一个函数时，只能传递参数（不能绑定this），他们的第一个参数会被忽略。（这种现象对于bind方法同样成立）
        3. 箭头函数不绑定`Arguments`对象。
        4. 箭头函数不能用作构造器，和`new`一起用会抛出错误。
        5. 箭头函数没有`prototype`属性。
        6. `yield`关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作函数生成器。
9. 浅拷贝和深拷贝。
    - 概念：浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。深拷贝就是在拷贝数据的时候，将数据的所有引用结构都拷贝一份。简单的说就是，在内存中存在两个数据结构完全相同又相互独立的数据，将引用型类型进行复制，而不是只复制其引用关系。
    - 实现：
        1. 浅拷贝的实现。直接赋值，`Object.assign()`，以及解构都是浅拷贝的形式。最多只能改变外层的指向，对象内部的引用依然是指向同一个地址。
        2. 深拷贝的实现。`lodash`的`cloneDeep`，`jquery`的`$.extend`，自己手写递归去拷贝以及`JSON.parse(JSON.stringify(obj))`。最后一种方式坑比较多，存在很多问题：
            * 如果对象中存在时间对象，则序列化结果：时间对象=>字符串的形式
            * 如果有`RegExp`和`Error`对象，则序列化的结果是个空对象：`RegExp`，`Error` => {}
            * 如果有`function`和`undefined`，则序列化的结果会把这两种数据丢失。
            * 如果有`NaN`，`Infinity`和`-Infinity`，则序列化结果会变成`null`。
            * 如果有由构造函数生成的对象，则序列化结果会丢弃对象的`constructor`属性。
            * 如果对象中存在循环引用的情况，无法实现深拷贝，会直接报错。
        3. 一种深拷贝的实现方式：

        ```js
        // 是否是一个可以遍历的合法对象或数组
        function isObject(obj) {
            return ['[object Object]', '[object Array]'].includes(Object.prototype.toString.apply(obj)) && obj != null;
        }

        // 是否循环引用
        /***
        * source 原始对象
        * target 已经拷贝的目标对象
        * sourceData 原始对象中的某个值
        */
        function isCyclicRefer(source, target, sourceData) {
            let isCyclicRefer = source === sourceData;
            for(let key in source) {
                if(source[key] === sourceData) {
                    isCyclicRefer = true;
                }
            }
            for(let key in target) {
                if(target[key] === sourceData) {
                    isCyclicRefer = true;
                }
            }
            return isCyclicRefer;
        }

        function deepClone(source) {
            if(!isObject(source)) {
                throw new Error('Please input object or array');
            }
            const target = Array.isArray(source) ? [] : {};
            for(let key in source) {
                const value = source[key];
                if(source.hasOwnProperty(key)) {
                    if(isObject(value) && !isCyclicRefer(source, target, value)) {
                        target[key] = deepClone(value);
                    } else {
                        target[key] = value;
                    }
                }
            }
            return target;
        }

        const a = {
            c: 2
        };
        a.b = a;
        const c = deepClone(a);
        console.log(c); // { c: 2, b: { c: 2, b: ... } }
        console.log(c === a); // false
        ```
10. `new`。
    - `new`一个对象时候的操作
        1. 创建了一个空对象。
        2. 把该空对象的`_proto_`指向函数的原型对象`prototype`。
        3. 将上下文`this`到该空对象上并在该对象上执行构造器函数。
        4. 如果函数没有返回对象，就返回this。
    - 自定义实现`new`功能。
        ```js
        // 借助了Objec.create
        function myNew(...args) {
            const constructor = args[0];
            if (typeof constructor !== 'function') {
                throw new Error('please input a valid constructor');
            }
            // 这样产生的空对象是没有原型链的空对象
            const obj = Object.create(constructor.prototype); // new的第一步与第二步的合并，产生一个原型链指向构造器的新对象。
            const _obj = constructor.apply(obj, args.slice(1)); // new的第三步，绑定构造器执行的上下文，并执行构造器方法，以及参数的传递
            return typeof _obj === 'object' ? _obj : obj; // new的第四步，如果没有返回一个对象就直接返回obj
        }
        // 借助了闭包
        function New(fn) {
            return function () {
                const obj = { '__proto__': fn.prototype }; // new的第一步与第二步的合并，产生一个原型链指向构造器的新对象。
                const _obj = fn.apply(obj, arguments); // new的第三步，绑定构造器执行的上下文，并执行构造器方法，以及参数的传递
                return typeof _obj === 'object' ? _obj : obj; // new的第四步，如果没有返回一个对象就直接返回obj
            }
        }

        function People(name, age) {
            this.name = name;
            this.age = age;
        }
        const man = myNew(People, 'xiaoming', 18);
        console.log(man); // People { name: 'xiaoming', age: 18 }
        console.log(man instanceof People); // true

        const woman = new People('xiaohong', 16);
        console.log(woman); // People { name: 'xiaohong', age: 16 }
        console.log(woman instanceof People); // true

        const p1 = New(People)('chen', 22);
        console.log(p1); // People { name: 'chen', age: 22 }
        console.log(p1 instanceof People); // true
        ```
11. 双向绑定。
    - 实现的几种方式。
        1. 发布-订阅者（又叫观察者）模式。实现对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。dom的监听事件，websocket通信都是属于观察者模式。
        2. 脏检查。angular.js在使用。通过检查数据是否变化来及时更新视图。angular.js为例，只会在特定事件下才会触发脏检查操作。脏检查之后会从rootscope开始遍历， 检查所有的watcher。 
            * DOM事件，譬如用户输入文本，点击按钮等。( ng-click )
            * XHR响应事件( $http )
            * 浏览器Location变更事件( $location )
            * Timer事件( $timeout , $interval )
            * 执行digest()或digest()或apply()
        3. 数据劫持。`Object.defineProperty`和ES6的`proxy`，`vue`的双向绑定就从前一种方式更新到后一种方式了。
    - 双向绑定的功能。保证从界面的操作能实时反映到数据，数据的变更能实时展现到界面。
    - 应用场景。
        1. 表单的数据获取，在用户输入完成后，逻辑层能直接获取到对应的数据，在获取到最新的数据时，能及时的更新表单展示。
        2. 大多数UI组件在交互时需要与数据保持同步，数据的变化影响UI，UI的交互影响数据。
12. script标签中的`defer`与`async`的区别。
    - `defer`。脚本会先进行下载但是会被延迟到整个页面都解析完毕后再运行。
    - `async`。浏览器不必等脚本下载完毕和执行完成后再加载页面，多个`async`的`script`标签执行顺序时不确定的。
13. 声明变量操作符的区别。
    - `var`定义的变量会自动把定义提升到当前作用域的顶部，`let`不会。
    ```js
    console.log(a); // undefined
    console.log(b); // Uncaught ReferenceError: b is not defined

    var a = 1; // 这个地方相当于在定于var a; 然后在这个位置a = 1。
    let b = 2;
    ```
    - `var`没有块作用域的概念，`let`有。
    ```js
    {
        var a = 1;
    }
    {
        let b = 2;
    }
    console.log(a); // 1
    console.log(b); // Uncaught ReferenceError: b is not defined
    ```
    - 使用`var`声明的变量可以被重新声明，`let`不会。
    - 使用`var`定义的变量属于`window`对象，可以使用`window.valName`的形式调用，`let`不行。
    - `const`与`let`类似，但是`const`定义的变量只可以在定义的时候被赋值一次。
14. `HTML`相关的`JSAPI`。
    - `postMessage`跨域操作。
    - `File`，`FileReader`文件操作
    - `Encoding API`。新增了`TextEncoder`、`TextEncoderStream`、`TextDecoder` 和 `TextDecoderStream`。
    - 音视频`API`。
    - 拖拽`API`。
    - `Notifications API`。用于向用户显示通知。
    - `Page Visibility API`，为开发者提供页面对用户是否可见的信息。
    - `Streams API`。流的处理。
    - web组件规范。
    - `Web Cryptography API`。描述了一套密码学工具，规范了`JavaScript`如何以安全和符合惯例的方式实现加密。
15. 同步异步，阻塞非阻塞。
    - 同步和异步关注的是消息通信机制。阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态。
    - 同步：由调用者主动等待调用结果的返回，此次调用执行多久，调用者就要等待多久。
    - 异步：由执行者在执行完成之后将结果通知给调用者，调用者在执行期间去做别的事情，通常是基于观察者模式实现。
    - 阻塞：在调用结果返回之前，当前的线程被挂起，无法执行其它操作。
    - 非阻塞：在调用结果返回之前，当前线程先去执行其它的调用，此时的状态就是非阻塞的。
16. 跨域的解决方案：
    - 通过jsonp跨域。（常用）
    - document.domain + iframe跨域
    - location.hash + iframe
    - window.name + iframe跨域
    - postMessage跨域。（常用）
    - 跨域资源共享（CORS），服务端设置资源的请求头`Access-Control-Allow-Origin`。（常用）
    - nginx代理跨域。（常用）
    - nodejs中间件代理跨域。（常用）
    - WebSocket协议跨域。
17. 节流和防抖。
    - 防抖。就是指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。
    - 节流。就是指连续触发事件但是在 n 秒中只执行一次函数。
    ```js
    // 节流
    function throttle(fn, threshhold) {
        // 记录上次执行的时间
        var last
        // 定时器
        var timer
        // 默认间隔为 250ms
        threshhold || (threshhold = 250)
        // 返回的函数，每过 threshhold 毫秒就执行一次 fn 函数
        return function() {
            // 保存函数调用时的上下文和参数，传递给 fn
            var context = this
            var args = arguments
            var now = +new Date()
            // 如果距离上次执行 fn 函数的时间小于 threshhold，那么就放弃
            // 执行 fn，并重新计时
            if (last && now < last + threshhold) {
                clearTimeout(timer)
                // 保证在当前时间区间结束后，再执行一次 fn
                timer = setTimeout(function() {
                    last = now
                    fn.apply(context, args)
                }, threshhold)
                // 在时间区间的最开始和到达指定间隔的时候执行一次 fn
            } else {
                last = now
                fn.apply(context, args)
            }
        }
    }
    // 防抖
    /**
     *
     * @param fn {Function}   实际要执行的函数
     * @param delay {Number}  延迟时间，也就是阈值，单位是毫秒（ms）
     *
     * @return {Function}     返回一个“去弹跳”了的函数
     */
    function debounce(fn, delay) {
        // 定时器，用来 setTimeout
        var timer
        // 返回一个函数，这个函数会在一个时间区间结束后的 delay 毫秒时执行 fn 函数
        return function() {
            // 保存函数调用时的上下文和参数，传递给 fn
            var context = this
            var args = arguments
            // 每次这个返回的函数被调用，就清除定时器，以保证不执行 fn
            clearTimeout(timer)
            // 当返回的函数被最后一次调用后（也就是用户停止了某个连续的操作），
            // 再过 delay 毫秒就执行 fn
            timer = setTimeout(function() {
                fn.apply(context, args)
            }, delay)
        }
    }
    ```

### css相关知识点

1. 三角形的实现。使用圆角实现。
2. 居中。弹性盒子，定位，table布局。
3. 动画。分为帧动画（`animation`）和过渡动画（`transition`）以及JS动画。
4. 自适应布局与响应式布局的实现。meta标签，媒体查询，rem，弹性盒子结合。`@media only screen and (max-width: 600px){}`
5. 静态布局与流式布局的区别。静态布局所有尺寸都是用px，固定长宽，在任何设备上看都是一样大小。流式布局是在屏幕分辨率发生变化时，元素的长宽根据分辨率变化，整体的布局不会变化。
6. BFC（块级格式化上下文，Block Formatting Context）。
    - 产生的条件：
        1. body 根元素
        2. 浮动元素：float 除 none 以外的值
        3. 绝对定位元素：position (absolute、fixed)
        4. display 为 inline-block、table-cells、flex
        5. overflow 除了 visible 以外的值 (hidden、auto、scroll)
    - 应用：
        1. 外边距重合。两个BFC容器的外边距是不会融合而是叠加的。
        2. 清除浮动影响。
7. BEM（Block Element Modifier）命名规范。类似这种`.block__elem--modifier`规则。
8. css中可以继承的元素有哪些：
    1. 字体系列属性。`font-family`，`font-size`，`font-weight`，`font-style`。
    2. 文本系列属性。`text-indent`，`text-align`，`line-height`，`word-spacing`，`letter-spacing`，`text-transform`，`color`。
    3. 元素可见性。`visibility`
    4. 列表布局属性。`list-style`，`list-style-type`，`list-style-image`。
    5. 光标属性。`cursor`。
9. 选择器优先级：`!important` > `行内` > `id` > `class` > `标签` > `通配*` > `继承属性` > `浏览器默认属性`。
10. 盒模型分类。`box-sizing`。`content-box`(实际宽度等于width+padding+border，实际占页面大小还要加上margin)与`border-box`（实际宽度与width一致，实际占页面大小width+margin）。

### 算法相关

1. 二叉树遍历的三种遍历方式。前中后是对于根节点来说的。
    - 前序遍历：先遍历根结点，然后左子树，再右子树。
    - 中序遍历：先遍历左子树，然后根结点，再右子树。
    - 后序遍历：先遍历左子树，然后右子树，再根结点。
2. 二叉树的非递归遍历。
    - 深度优先遍历（主要利用栈的先进后出）
    - 广度优先遍历（主要利用队列的先进先出）
3. 排序的分类：
    - 冒泡排序。循环比较相邻两个元素的大小。时间复杂度：O（n²）。n值较小时，选择排序比冒泡排序快。
    - 选择排序。循环每次选出剩余的数组中最大或最小的值。时间复杂度：O（n²）。
    - 插入排序。使用双重循环，外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动。时间复杂度：O(N)~O(N²)。
    - 归并排序。将数组两两拆分先排序分解后的子数组，再合并之后继续排序。时间复杂度：O(nlogn)
    - 快速排序法。设定分界值，数组分两边，两边再取分界值，继续分两边，直到不可分，然后再组合，通常用递归。O(nlogn)。通常来说。快排要比归并排序更快。
    - 桶排序。只适合数组中的数字区间不会太大的情况下使用。直接弄一个长度足够长的数组，然后把待排序的数组的每一项都往这个数组中去放，放置的条件是目标数组的值与空数组的下标一直，或存在一定对应关系。

### 优化相关

1. 雪碧图，减少图片资源的加载。(减少HTTP请求数)
2. 标签语义化，减少标签的嵌套。
3. 避免重复的css样式，重复使用的使用全局定义。
4. 避免使用@import的方式引入样式文件，该方式可能会阻塞页面加载。
5. 使用scss，less时，应减少css类名的嵌套，提高浏览器解析的速度。
6. 少使用css通配符，会增加解析的计算量。
7. 对于需要使用动画的地方，开启GPU硬件加速，`transform: translate3d(0,0,0)`。
8. 使用webp的图片，但是ios不支持。
9. 不声明过多的font-size，降低了生成css树的效率。
10. 谨慎使用fixed，在ios中fixed容易出错，软键盘弹出时影响位置。
11. 大量的事件监听直接通过事件委托去实现。
12. 利用节流和防抖去处理高频触发以及在规定时间内只允许触发一次的交互。如输入框的搜索以及提交按钮的重复点击。
13. JS动画使用`requestAnimationFrame`，而不是`setTimeout`与`setInterval`。
14. 防止大量的dom操作以及dom位置的变化，减少浏览器的回流。
15. 复杂的数据计算可以使用`Web Worker`去实现。
16. 使用`link`标签的`rel`的`preload`，`prefetch`，`prerendering`，`preconnect`去预加载资源和预渲染页面。
17. 线上的媒体资源使用CDN服务器托管。
18. 开启服务端的gzip压缩。
19. 避免资源的重定向，减少等待时间。
20. 使用`webpack-bundle-analyzer`去分析当前项目的打包的大小，合理进行拆分。
21. 过大的第三方库，不要打包到项目中，可以采用html的script标签去加载。
22. 使用DLL动态链接库。把不常更新的`module`进行编译打包，然后每次开发和上线就只针对开发过程中相
关的文件进行打包。主要用到了`DllPlugin`和`DLLReferencePlugin`两个插件。
23. antd等第三方UI库的按需加载。
24. 异步加载模块，懒加载。
25. 压缩混淆代码，移除console。通过插件`UglifyJSPlugin`实现。
26. 使用`HappyPack`提升打包速度。`HappyPack`是让`webpack`对`loader`的执行过程，从单一进程形式扩展
为多进程模式，也就是将任务分解给多个子进程去并发的执行，子进程处理完后再把结果发送给主进
程。从而加速代码构建 与 DLL动态链接库结合来使用更佳。
27. 使用Tree Shaking移除JavaScript中用不上的代码，它依赖静态的ES6模块化语法，例如通过impot和
export导入导出。在mode为production的情况下，会默认开启Tree Shaking。